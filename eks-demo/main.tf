terraform {

  required_version = ">=1.3.0"

  cloud {
    organization = "AWS-TF-GH-CODESPACE"
    workspaces {
      name = "aws-terraform-codespace"
    }
  }  
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 6.23"
    }
    helm = {
      source  = "hashicorp/helm"
      version = "~> 2.17"
    }
    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = "~> 2.38"
    }
  }
}

provider "aws" {
  region = var.region
}

module "vpc" {

  source = "./modules/vpc"
  

  region              = var.region
  vpc_cidr            = var.vpc_cidr
  availability_zones  = var.availability_zones  # List of availability zones to distribute subnets across
  private_subnet_cidr = var.private_subnet_cidr # CIDR blocks for private subnets
  public_subnet_cidr  = var.public_subnet_cidr  # CIDR blocks for public subnets
  eks_cluster_name    = var.eks_cluster_name    # Optional: used inside VPC module for tagging or naming
}

module "eks" {
  source = "./modules/eks"

  region           = var.region
  eks_cluster_name = var.eks_cluster_name         # Name of the EKS cluster to create
  cluster_version  = var.cluster_version          # Kubernetes version for the EKS control plane
  vpc_id           = module.vpc.vpc_id            # Use VPC ID output from the VPC module
  subnet_ids        = module.vpc.private_subnet_ids # Use private subnet IDs from the VPC module
}

###############################3

# 1. Get Authentication Data from EKS Cluster
data "aws_eks_cluster" "cluster" {
  name = module.eks.cluster_name

  # CRITICAL FIX: Explicitly wait for the EKS module to be completely done
 # depends_on = [
 #   module.eks
  #]
}

data "aws_eks_cluster_auth" "cluster_auth" {
  name = module.eks.cluster_name

  # CRITICAL FIX: Explicitly wait for the EKS module to be completely done
  #depends_on = [
  #  module.eks
  #]


}

# 2. Configure the Kubernetes Provider
provider "kubernetes" {
  # Use the EKS Cluster API Endpoint
  host                   = data.aws_eks_cluster.cluster.endpoint
  
  # Use the Cluster CA Certificate
  cluster_ca_certificate = base64decode(data.aws_eks_cluster.cluster.certificate_authority[0].data)

  # FIX: Use the token generated by the working AWS Provider
  token                  = data.aws_eks_cluster_auth.cluster_auth.token
  
  # CRITICAL: Use the AWS CLI to get the temporary token for authentication
  # exec {
  #   api_version = "client.authentication.k8s.io/v1beta1"
  #   command     = "aws"
  #   args        = ["eks", "get-token", "--cluster-name", var.eks_cluster_name]
  # }  ###########exec can be used if the aws configure has profile #################
}

#######################################################


provider "helm" {
  # Configure the Helm provider to connect via the Kubernetes block
  kubernetes {
    # Use the EKS Cluster API Endpoint
    host                   = data.aws_eks_cluster.cluster.endpoint
    
    # Use the Cluster CA Certificate
    cluster_ca_certificate = base64decode(data.aws_eks_cluster.cluster.certificate_authority[0].data)

    # FIX: Use the token generated by the working AWS Provider
    token                  = data.aws_eks_cluster_auth.cluster_auth.token
    
    # CRITICAL: Use the AWS CLI exec command for dynamic authentication
    # exec {
    #   api_version = "client.authentication.k8s.io/v1beta1"
    #   command     = "aws"
    #   args        = ["eks", "get-token", "--cluster-name", var.eks_cluster_name]
    # }
  }
}

##############################################3