terraform {

  required_version = ">=1.3.0"

  cloud {
    organization = "AWS-TF-GH-CODESPACE"
    workspaces {
      name = "aws-terraform-codespace"
    }
  }  
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 6.23"
    }
    helm = {
      source  = "hashicorp/helm"
      version = "~> 2.17"
    }
    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = "~> 2.38"
    }
  }
}

provider "aws" {
  region = var.region
}

module "vpc" {

  source = "./modules/vpc"
  

  region              = var.region
  vpc_cidr            = var.vpc_cidr
  availability_zones  = var.availability_zones  # List of availability zones to distribute subnets across
  private_subnet_cidr = var.private_subnet_cidr # CIDR blocks for private subnets
  public_subnet_cidr  = var.public_subnet_cidr  # CIDR blocks for public subnets
  eks_cluster_name    = var.eks_cluster_name    # Optional: used inside VPC module for tagging or naming
}

module "eks" {
  source = "./modules/eks"

  region           = var.region
  eks_cluster_name = var.eks_cluster_name         # Name of the EKS cluster to create
  cluster_version  = var.cluster_version          # Kubernetes version for the EKS control plane
  vpc_id           = module.vpc.vpc_id            # Use VPC ID output from the VPC module
  subnet_ids        = module.vpc.private_subnet_ids # Use private subnet IDs from the VPC module
  #security_group_ids = module.eks.aws_security_group
}

###############################Apply 2##############################

# 1. Get Authentication Data from EKS Cluster
data "aws_eks_cluster" "cluster" {
  name = module.eks.cluster_name

  # CRITICAL FIX: Explicitly wait for the EKS module to be completely done
 # depends_on = [
 #   module.eks
  #]
}

data "aws_eks_cluster_auth" "cluster_auth" {
  name = module.eks.cluster_name

  # CRITICAL FIX: Explicitly wait for the EKS module to be completely done
  #depends_on = [
  #  module.eks
  #]


}

# 2. Configure the Kubernetes Provider
provider "kubernetes" {
  # Use the EKS Cluster API Endpoint
  host                   = data.aws_eks_cluster.cluster.endpoint
  
  # Use the Cluster CA Certificate
  cluster_ca_certificate = base64decode(data.aws_eks_cluster.cluster.certificate_authority[0].data)

  # FIX: Use the token generated by the working AWS Provider
  token                  = data.aws_eks_cluster_auth.cluster_auth.token
  
  # CRITICAL: Use the AWS CLI to get the temporary token for authentication
  # exec {
  #   api_version = "client.authentication.k8s.io/v1beta1"
  #   command     = "aws"
  #   args        = ["eks", "get-token", "--cluster-name", var.eks_cluster_name]
  # }  ###########exec can be used if the aws configure has profile #################
}

#######################################################

resource "kubernetes_manifest" "lbc_security_group_policy" {
  provider = kubernetes # Must use the kubernetes provider

  manifest = {
    "apiVersion" = "vpcresources.k8s.aws/v1beta1"
    "kind"       = "SecurityGroupPolicy"
    "metadata" = {
      "name"      = "lbc-security-group-policy"
      "namespace" = "kube-system" # Targets LBC pods in kube-system
    }
    "spec" = {
      "podSelector" = {
        "matchLabels" = {
          "app.kubernetes.io/name" = "aws-load-balancer-controller"
        }
      }
      "securityGroups" = {
        "groupIds" = [
          try(tolist(module.eks.cluster_security_group_id)[0], "sg-placeholder-cluster"),
          tostring(module.eks.fargate_egress_security_group_id),
        ]
      }
    }
  }
  # CRITICAL: Ensures the policy is applied AFTER the cluster is ready.
  depends_on = [
    module.eks
    # Ensure you depend on the kubernetes provider initialization too.
  ]
}

resource "kubernetes_manifest" "game_security_group_policy" {
  provider = kubernetes 

  manifest = {
    "apiVersion" = "vpcresources.k8s.aws/v1beta1"
    "kind"       = "SecurityGroupPolicy"
    "metadata" = {
      "name"      = "game-security-group-policy"
      "namespace" = "game2048"
    }
    "spec" = {
      "podSelector" = {
        "matchLabels" = {
          "app" = "2048" # Use the label selector for your 2048 deployment
        }
      }
      "securityGroups" = {
        "groupIds" = [
          try(tolist(module.eks.cluster_security_group_id)[0], "sg-placeholder-cluster"),
          tostring(module.eks.fargate_egress_security_group_id),
        ]
      }
    }
  }
}


provider "helm" {
  # Configure the Helm provider to connect via the Kubernetes block
  kubernetes {
    # Use the EKS Cluster API Endpoint
    host                   = data.aws_eks_cluster.cluster.endpoint
    
    # Use the Cluster CA Certificate
    cluster_ca_certificate = base64decode(data.aws_eks_cluster.cluster.certificate_authority[0].data)

    # FIX: Use the token generated by the working AWS Provider
    token                  = data.aws_eks_cluster_auth.cluster_auth.token
    
    # CRITICAL: Use the AWS CLI exec command for dynamic authentication
    # exec {
    #   api_version = "client.authentication.k8s.io/v1beta1"
    #   command     = "aws"
    #   args        = ["eks", "get-token", "--cluster-name", var.eks_cluster_name]
    # }
  }
}

##############################################3